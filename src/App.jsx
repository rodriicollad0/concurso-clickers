import { useState, useEffect } from 'react';
import { ServiceForm } from './components/ServiceForm';
import { BookingSummary } from './components/BookingSummary';
import './App.css';

/**
 * Componente principal de la aplicaci√≥n de reservas para peluquer√≠a
 * Implementa Web Serial API para comunicaci√≥n con dispositivos externos
 * @author Rodrigo Collado
 */
function App() {
  // Estados para el sistema de reservas
  const [booking, setBooking] = useState(null);
  
  // Estados para la comunicaci√≥n serial usando Web Serial API
  const [serialOutput, setSerialOutput] = useState(''); // Log de comunicaci√≥n serial
  const [port, setPort] = useState(null); // Puerto serie activo
  const [reader, setReader] = useState(null); // Reader para lectura de datos
  const [isConnected, setIsConnected] = useState(false); // Estado de conexi√≥n
  const [isConnecting, setIsConnecting] = useState(false); // Estado de conexi√≥n en progreso

  // Verificar compatibilidad con Web Serial API
  // La Web Serial API solo est√° disponible en navegadores compatibles (Chrome, Edge)
  const isSerialSupported = 'serial' in navigator;
  
  // Detecci√≥n de plataforma m√≥vil para mostrar advertencias apropiadas
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // Detecci√≥n espec√≠fica de Android con Chrome
  const isAndroidChrome = /Android.*Chrome/i.test(navigator.userAgent);
  
  /**
   * Extrae la versi√≥n de Android del user agent
   * @returns {number} Versi√≥n de Android o 0 si no se detecta
   */
  const getAndroidVersion = () => {
    const match = navigator.userAgent.match(/Android\s([0-9\.]*)/);
    return match ? parseFloat(match[1]) : 0;
  };
  
  const androidVersion = getAndroidVersion();
  // Web Serial API en Android requiere versi√≥n 12+ y flags experimentales habilitadas
  const isCompatibleAndroid = isAndroidChrome && androidVersion >= 12;

  /**
   * Maneja la creaci√≥n de una nueva reserva
   * Si hay un dispositivo serial conectado, env√≠a los datos autom√°ticamente
   * @param {Object} bookingData - Datos de la reserva (nombre, servicio, fecha, hora)
   */
  const handleBook = (bookingData) => {
    setBooking(bookingData);
    
    // Enviar datos al dispositivo serial si est√° conectado
    // Esto permite integraci√≥n con sistemas externos (displays, impresoras, etc.)
    if (isConnected && port) {
      sendToSerial(`NUEVA_RESERVA:${bookingData.name}|${bookingData.service}|${bookingData.date}|${bookingData.time}\n`);
    }
  };

  /**
   * Vuelve al formulario principal desde el resumen de reserva
   */
  const handleBack = () => {
    setBooking(null);
  };

  /**
   * Env√≠a datos a trav√©s del puerto serie usando Web Serial API
   * @param {string} data - Datos a enviar al dispositivo
   */
  const sendToSerial = async (data) => {
    if (!port || !isConnected) return;
    
    try {
      // Obtener un writer para el puerto serie
      const writer = port.writable.getWriter();
      // Codificar string a bytes y enviar
      await writer.write(new TextEncoder().encode(data));
      // Liberar el writer para otros usos
      writer.releaseLock();
      setSerialOutput(prev => prev + `üì§ Enviado: ${data}`);
    } catch (error) {
      console.error('Error enviando datos:', error);
      setSerialOutput(prev => prev + `‚ùå Error enviando datos: ${error.message}\n`);
    }
  };

  /**
   * Establece conexi√≥n con un dispositivo serial usando Web Serial API
   * Implementa manejo robusto de errores y reconexi√≥n autom√°tica
   */
  const handleConnectSerial = async () => {
    // Verificar compatibilidad del navegador con Web Serial API
    if (!isSerialSupported) {
      setSerialOutput('‚ùå Tu navegador no soporta Web Serial API. Usa Chrome/Edge.\n');
      return;
    }

    // Limpiar conexiones previas para evitar conflictos
    if (isConnected || port) {
      setSerialOutput(prev => prev + 'üîÑ Desconectando conexi√≥n previa...\n');
      await handleDisconnectSerial();
      // Tiempo de espera para liberaci√≥n completa de recursos
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    setIsConnecting(true);
    
    try {
      // Solicitar al usuario que seleccione un puerto serie
      // Esto abre un di√°logo del navegador con puertos disponibles
      const requestedPort = await navigator.serial.requestPort();
      
      // Verificar si el puerto ya est√° en uso por otra aplicaci√≥n
      if (requestedPort.readable) {
        setSerialOutput('‚ö†Ô∏è El puerto ya estaba abierto. Cerrando conexi√≥n previa...\n');
        try {
          await requestedPort.close();
          await new Promise(resolve => setTimeout(resolve, 200));
        } catch (closeError) {
          console.log('Puerto ya estaba cerrado o no se pudo cerrar:', closeError);
        }
      }

      setSerialOutput(prev => prev + 'üîÑ Intentando abrir puerto serie...\n');
      
      // Configurar par√°metros de comunicaci√≥n serial
      // baudRate: velocidad de transmisi√≥n (bits por segundo)
      // dataBits: bits de datos por frame
      // stopBits: bits de parada
      // parity: control de paridad
      // flowControl: control de flujo de datos
      await requestedPort.open({ 
        baudRate: 9600,    // Velocidad est√°ndar para Arduino y microcontroladores
        dataBits: 8,       // 8 bits de datos (est√°ndar)
        stopBits: 1,       // 1 bit de parada (est√°ndar)
        parity: 'none',    // Sin paridad
        flowControl: 'none' // Sin control de flujo
      });

      // Configurar stream de decodificaci√≥n para datos entrantes
      // TextDecoderStream convierte bytes a texto legible
      const decoder = new TextDecoderStream();
      requestedPort.readable.pipeTo(decoder.writable);
      const newReader = decoder.readable.getReader();

      // Actualizar estados de la aplicaci√≥n
      setPort(requestedPort);
      setReader(newReader);
      setIsConnected(true);
      setSerialOutput(prev => prev + '‚úÖ Conectado correctamente al dispositivo serial.\n');

      /**
       * Bucle infinito para leer datos del puerto serie
       * Se ejecuta en segundo plano mientras la conexi√≥n est√© activa
       */
      const readLoop = async () => {
        try {
          // Leer datos mientras la conexi√≥n est√© activa
          while (isConnected) {
            const { value, done } = await newReader.read();
            // Salir si la lectura est√° completa o la conexi√≥n se cerr√≥
            if (done || !isConnected) {
              console.log('Lectura terminada, saliendo del bucle');
              break;
            }
            // Mostrar datos recibidos en la interfaz
            if (value) {
              setSerialOutput(prev => prev + `üì• Recibido: ${value}`);
            }
          }
        } catch (error) {
          console.error('Error leyendo datos:', error);
          // Solo mostrar errores que no sean de cancelaci√≥n esperada
          if (error.name !== 'AbortError' && isConnected) {
            setSerialOutput(prev => prev + `‚ùå Error leyendo datos: ${error.message}\n`);
          }
        } finally {
          // Limpiar recursos cuando termine el bucle
          console.log('Liberando reader en readLoop');
          try {
            newReader.releaseLock();
          } catch (releaseError) {
            console.log('Reader ya estaba liberado:', releaseError);
          }
        }
      };

      // Iniciar el bucle de lectura en segundo plano
      readLoop();

    } catch (err) {
      console.error('‚ùå Error al conectar al puerto serie:', err);
      
      // Proporcionar mensajes de error espec√≠ficos seg√∫n el tipo de fallo
      let errorMessage = '';
      if (err.message.includes('Failed to open serial port')) {
        errorMessage = `‚ùå No se pudo abrir el puerto serie. Posibles causas:
üìç El puerto est√° siendo usado por otra aplicaci√≥n
üìç El dispositivo no est√° conectado correctamente
üìç Permisos insuficientes
üí° Soluciones:
  ‚Ä¢ Cierra otros programas que usen el puerto (Arduino IDE, PuTTY, etc.)
  ‚Ä¢ Desconecta y reconecta el dispositivo USB
  ‚Ä¢ Reinicia el navegador
  ‚Ä¢ Verifica que el dispositivo est√© en COM4
`;
      } else if (err.name === 'NotFoundError') {
        errorMessage = '‚ùå No se seleccion√≥ ning√∫n puerto serie.\n';
      } else if (err.name === 'SecurityError') {
        errorMessage = '‚ùå Error de seguridad. El navegador bloque√≥ el acceso al puerto serie.\n';
      } else {
        errorMessage = `‚ùå Error al conectar: ${err.message}\n`;
      }
      
      setSerialOutput(prev => prev + errorMessage);
      // Limpiar estados en caso de error
      setIsConnected(false);
      setPort(null);
      setReader(null);
    } finally {
      setIsConnecting(false);
    }
  };

  /**
   * Cierra la conexi√≥n serial de forma segura
   * Implementa secuencia correcta para evitar errores de stream bloqueado
   */
  const handleDisconnectSerial = async () => {
    // Verificar si hay una conexi√≥n activa
    if (!port && !isConnected) return; // Ya est√° desconectado
    
    try {
      setSerialOutput(prev => prev + 'üîÑ Desconectando dispositivo...\n');
      
      // PASO 1: Marcar como desconectado para detener el bucle de lectura
      // Esto es crucial para evitar conflictos con el reader
      setIsConnected(false);
      
      // PASO 2: Esperar a que el bucle de lectura termine naturalmente
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // PASO 3: Cancelar el reader si existe
      if (reader) {
        try {
          await reader.cancel(); // Cancela operaciones pendientes
          setSerialOutput(prev => prev + 'üîÑ Reader cancelado...\n');
        } catch (cancelError) {
          console.log('Error cancelando reader:', cancelError);
          setSerialOutput(prev => prev + '‚ö†Ô∏è Reader ya estaba cancelado...\n');
        }
        setReader(null);
      }
      
      // PASO 4: Esperar para asegurar liberaci√≥n completa del stream
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // PASO 5: Cerrar el puerto f√≠sico
      if (port && port.readable) {
        try {
          await port.close(); // Cierra la conexi√≥n f√≠sica
          setSerialOutput(prev => prev + 'üîÑ Puerto cerrado...\n');
        } catch (closeError) {
          console.log('Error cerrando puerto:', closeError);
          setSerialOutput(prev => prev + '‚ö†Ô∏è Puerto ya estaba cerrado...\n');
        }
      }
      
      setPort(null);
      setSerialOutput(prev => prev + '‚úÖ Dispositivo desconectado correctamente.\n');
      
    } catch (error) {
      console.error('Error desconectando:', error);
      setSerialOutput(prev => prev + `‚ùå Error desconectando: ${error.message}\n`);
    } finally {
      // PASO 6: Forzar reset del estado sin importar errores
      // Esto asegura que la UI refleje el estado real
      setPort(null);
      setReader(null);
      setIsConnected(false);
    }
  };

  /**
   * Limpia el historial de comunicaci√≥n serial
   */
  const clearSerialOutput = () => {
    setSerialOutput('');
  };

  /**
   * Cleanup al desmontar el componente
   * Asegura que las conexiones se cierren correctamente al cerrar la app
   */
  useEffect(() => {
    return () => {
      if (port && isConnected) {
        handleDisconnectSerial();
      }
    };
  }, [port, isConnected, reader]);

  return (
    <div className="app">
      <h1 className="app-title">Peluquer√≠a - Sistema de Reservas</h1>

      {/* SECCI√ìN: Controles Web Serial API */}
      {/* Solo se muestra si el navegador soporta Web Serial API */}
      {isSerialSupported && (
        <div className="serial-controls">
          <div className="serial-buttons">
            {/* Bot√≥n de conexi√≥n - cambia estado seg√∫n conexi√≥n */}
            <button
              onClick={handleConnectSerial}
              disabled={isConnected || isConnecting}
              className={`connect-serial-button ${isConnected ? 'connected' : ''}`}
            >
              {isConnecting ? 'üîÑ Conectando...' : isConnected ? '‚úÖ Conectado' : 'üîå Conectar dispositivo'}
            </button>

            {/* Bot√≥n de desconexi√≥n - solo visible cuando hay conexi√≥n */}
            {isConnected && (
              <button
                onClick={handleDisconnectSerial}
                className="disconnect-serial-button"
              >
                üîå Desconectar
              </button>
            )}

            {/* Bot√≥n para limpiar historial - solo visible cuando hay salida */}
            {serialOutput && (
              <button
                onClick={clearSerialOutput}
                className="clear-output-button"
              >
                üßπ Limpiar
              </button>
            )}
          </div>

          {/* Indicador visual del estado de conexi√≥n */}
          <div className="connection-status">
            <span className={`status-indicator ${isConnected ? 'connected' : 'disconnected'}`}>
              ‚óè
            </span>
            <span className="status-text">
              {isConnected ? 'Dispositivo conectado' : 'Dispositivo desconectado'}
            </span>
          </div>
        </div>
      )}

      {/* SECCI√ìN: Advertencias de compatibilidad */}
      {/* Se muestra cuando Web Serial API no est√° disponible */}
      {!isSerialSupported && (
        <div className="serial-warning">
          {isMobile ? (
            isAndroidChrome ? (
              androidVersion < 12 ? (
                <div>
                  üì± <strong>Android {androidVersion}</strong> detectado. 
                  <br />‚ö†Ô∏è Web Serial API requiere <strong>Android 12+</strong> con Chrome.
                  <br />üîÑ Actualiza tu Android o usa Chrome en PC.
                </div>
              ) : (
                <div>
                  üì± <strong>Android {androidVersion}</strong> detectado con Chrome.
                  <br />üîß Web Serial API puede no estar habilitada. 
                  <br />üí° Activa flags experimentales en <code>chrome://flags</code>
                </div>
              )
            ) : (
              <div>
                üì± <strong>M√≥vil detectado:</strong> Web Serial API no disponible.
                <br />‚úÖ <strong>Soluci√≥n:</strong> Usa Chrome en Android 12+ o Chrome/Edge en PC.
              </div>
            )
          ) : (
            <div>
              üñ•Ô∏è <strong>PC detectado:</strong> Web Serial API no disponible.
              <br />‚úÖ <strong>Soluci√≥n:</strong> Usa Chrome o Edge para conectar dispositivos seriales.
            </div>
          )}
        </div>
      )}

      {/* SECCI√ìN: Consola de comunicaci√≥n serial */}
      {/* Muestra el log de comunicaci√≥n con el dispositivo */}
      {serialOutput && (
        <div className="serial-output">
          <div className="serial-output-header">
            <strong>üì° Comunicaci√≥n Serial:</strong>
          </div>
          <pre className="serial-content">{serialOutput}</pre>
        </div>
      )}

      {/* SECCI√ìN: Contenido principal de la aplicaci√≥n */}
      <div className="app-content">
        {booking ? (
          // Vista del resumen de reserva
          <BookingSummary booking={booking} onBack={handleBack} />
        ) : (
          // Vista del formulario de reserva
          <ServiceForm onBook={handleBook} />
        )}
      </div>
    </div>
  );
}

export default App;
